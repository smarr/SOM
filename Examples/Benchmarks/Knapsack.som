Knapsack = Benchmark (
    getWeights = (
        | weights prng |
        weights := Vector new.
        prng := Random new.

        1 to: 100 do: [:w | | repetitions |
            repetitions := prng next % 50 + 20.
            repetitions timesRepeat: [ 
                weights append: w.
                weights size = 5000 ifTrue: [ 
                    ^ weights ] ] ].
        
        [ weights size < 5000 ] whileTrue: [
            weights append: 100 ].

        ^ weights
    )

    getRandomValues = (
        | values prng i |
        values := Vector new.
        prng := Random new.

        5000 timesRepeat: [
            values append: prng next % 100 ].

        ^ values
    )

    innerBenchmarkLoop: goal = (
        | ws vs result expectedResult eI |
        ws := self getWeights.
        vs := self getRandomValues.

        result := self knapsack: goal weights: ws values: vs.
        'result: ' print. result println.
        
        expectedResult := #(99 2226 3431 4289 4946 5520 6044 6530 7000 7435 7844 8244 8634 9018
                            9392 9751 10105 10453 10797 11133 11465 11793 12118 12438 12749
                            13056 13360 13659 13953 14242 14527 14805 15079 15348 15613 15875
                            16133 16388 16638 16887 17132).
        eI := goal / 25 + 1.

        "Remember: this is a bit brittle, and while the `expectedResults` where generated by this code
                   there seem to be cases where the below doesn't hold.
                   So, not all problem sizes will validate, but seems good enough for now."
        eI + 1 <= expectedResult length
            ifTrue: [
                ^ result >= (expectedResult at: eI) and: [ result <= (expectedResult at: eI + 1) ] ]
            ifFalse: [
                ^ result > expectedResult last ]
    )

    knapsack: goal weights: w values: v = (
        | m |
        ((w size <= 0) || (goal <= 0)) ifTrue: [ ^ 0 ].

        m := Vector new.
        1 to: 1 + w size do: [ :i |
            m append: Vector new.
            1 to: 1 + goal do: [ :j |
                (m at: i) append: 0 ] ].

        1 to: w size do: [ :i |
            1 to: goal do: [ :j |
                (w at: i) > j
                    ifTrue: [ (m at: i + 1) at: j + 1 put: ((m at: i) at: j + 1) ]
                    ifFalse: [ (m at: i + 1) at: j + 1 put: (((m at: i) at: j + 1) max: (((m at: i) at: j + 1 - (w at: i)) + (v at: i))) ]
            ]
        ].

        ^ (m at: w size) last
    )
)
